#OBJETIVO GERAL: Aprender a criar aplicações Fullstack com:
  - Angular(Frontend)
  - ASP.NET Core com ADO.NET(Backend)
  - SQL Server(Banco de dados)  
  - E entender o fluxo completo: do banco de dados até a tela,  e da tela até o banco de dados.
_________________________________________________________________________________________________________________________________________________________________________

#ETAPAS DA JORNADA (Vamos desbloquear aos poucos):
 1- Modelagem de banco de dados(começamos por aqui)
 2- Criar banco e tabela no SQL Server
 3- Criar API ASP.NET Core com ADO.NET(sem Entity Framework)
 4- Criar Frontend Angular simples com formulários reativos
 5- Fazer tudo se comunicar
 6- Aprender a debugar e resolver problemas
_______________________________________________________________________________________________________________________________________________________________________

🚶‍♂️ Etapa 1: Pensando como um Banco de Dados
Vamos imaginar que você tem um caderno e quer anotar informações de pessoas. O que você precisa guardar?

Desafio 1:
Sem pensar em código ainda — imagine que você vai montar uma tabela no papel com informações de uma pessoa.
O que você colocaria como colunas?

Exemplo: Nome, Idade, Email... e mais o quê?

🧠 Pense e me diga quais colunas você colocaria.
(E também me diga se alguma dessas colunas pode ser repetida, ou se precisa ser única — tipo um CPF.)
 R: Eu colocaria:
- ID(único e não pode repetir)
- Nome da pessoa
- Idade da pessoa
- CPF (Deve ser único e não pode repetir)
- Email da pessoa

#MODELO DE DADOS DESSA TABELA:
---------------------------------------------------------------------------------------
Coluna   | Tipo de dado esperado       | Regras					      |
---------|-----------------------------|----------------------------------------------|
ID       | Número inteiro              | Chave primária, único, gerado automático     |   
Nome     | Texto (string)              | Pode repetir                                 |
Idade    | Número inteiro (ou opcional)| Pode repetir                                 |
CPF      | Texto (string, 11 dígitos)  | Deve ser único  			      |
Email    | Texto                       | Pode ser único (depende da regra do sistema) |
---------------------------------------------------------------------------------------

_______________________________________________________________________________________________________________________________________________________________________

# Agora vem uma pergunta importante para você pensar:

🤔 Por que a gente usa um ID numérico automático em vez de usar o CPF como chave primária?
(Responda com sua lógica — sem medo de errar. Pode pensar alto mesmo.)

Depois que você responder isso, a gente já parte para criar essa tabela no SQL Server, via CREATE TABLE.
Só que primeiro, quero te ajudar a pensar como o banco pensa 😉

#RESPOSTA: 🧠 Conclusão (resposta para guardar):
 -A gente usa ID numérico como chave primária porque ele é simples, rápido, leve, imutável e ideal para ser referência interna entre tabelas (relacionamentos).
 -O CPF é uma informação única, sim, mas é do mundo real, e deve ser validado — não usado como chave.
_______________________________________________________________________________________________________________________________________________________________________

📦 O que vem antes de CREATE TABLE?
Antes de criar qualquer tabela, você precisa criar um banco de dados onde essa tabela vai existir.

🧠 Pense assim:
O banco de dados é como um arquivo de Excel, e cada tabela é uma aba dentro desse arquivo.

🔨 DESAFIO 2: Criar o banco de dados
Tente escrever um comando SQL que cria um banco de dados chamado MeuSistema.

Você consegue imaginar como seria?

Dica: é bem simples, algo assim:

COMANDO: CREATE DATABASE NomeDoBanco;

#MEU COMADO PARA CRIAR MEU BANCO: CREATE DATABASE Cadastro;


🧠 Tente você escrever agora o comando para criar um banco com nome MeuSistema.
(E depois vamos para a criação da tabela PESSOAS dentro dele.)

_______________________________________________________________________________________________________________________________________________________________________
🧪 DESAFIO 3: Agora vamos criar essa tabela no SQL Server
Vamos pensar: quais tipos de dados você colocaria em cada coluna?

Por exemplo:

-ID: inteiro (INT)

-Nome: texto curto (VARCHAR)

-Idade: número (INT)

-CPF: texto de 11 caracteres (VARCHAR(11))

-Email: texto (VARCHAR(100))

🧠 Tente montar agora o comando CREATE TABLE PESSOAS com base nisso.

#MEU COMANDO PARA CRIAR A TABELA FOI ESSE:

CREATE TABLE Pessoas(
	PES_ID INT PRIMARY KEY IDENTITY(1,1),
	PES_NOME VARCHAR(100),
	PES_IDADE INT,
	PES_CPF VARCHAR(11) UNIQUE,
	PES_EMAIL VARCHAR(100)
);

📌 Explicações rápidas:
IDENTITY(1,1) → significa: comece no 1, e vá somando de 1 em 1.

A ordem IDENTITY → depois PRIMARY KEY é só questão de estilo. O SQL aceita das duas formas.

VARCHAR(100) → você pode usar outro número, mas evite deixar muito grande ou muito pequeno.
Por exemplo, VARCHAR(10) para nome talvez corte nomes como Fernanda ou Alessandro.
_______________________________________________________________________________________________________________________________________________________________________

🧪 DESAFIO 4:
Agora que:

Você criou o banco

Criou a tabela

Me diga:
Se você quisesse inserir uma nova pessoa na tabela, como você faria isso?

🧠 Tente montar um INSERT INTO PESSOAS (...) VALUES (...) com os dados abaixo:

Nome: João Silva

Idade: 30

CPF: 12345678900

Email: joao@email.com

Lembrando: não precisa colocar o ID, porque ele é automático.

#MEU COMANDO PARA INSERIR DADOS NA TABELA DE CADASTRO:
INSERT INTO Pessoas
    (PES_NOME,
     PES_IDADE,
     PES_CPF,
     PES_EMAIL)
VALUES
    ('Lucas',
     27,
     '44003132053',
     'lucas@email.com'
);

🧠 Explicação rápida:
✅ A ordem dos campos está batendo com os valores.

✅ Você não incluiu o ID, o que está certo, pois ele é gerado automaticamente.

✅ Os valores de texto estão entre aspas simples '...', como deve ser.

✅ A quebra de linha e indentação estão limpas e legíveis (ótimo hábito!).
_______________________________________________________________________________________________________________________________________________________________________

🎯DESAFIO 5: 
Se você rodou esse comando e deu certo, o banco agora tem 1 pessoa cadastrada.

Agora eu quero que você pense e escreva um comando SQL que:

Mostre todas as pessoas cadastradas na tabela PESSOAS.
Como seria isso?

Dica: é um comando de leitura.
Pense com calma. Não precisa escrever perfeito de primeira — só tenta.

#MEU COMANDO PARA MOSTRAR TUDO: 
SELECT * FROM Pessoas;

Isso aí é o famoso: "Me mostra tudo de todo mundo que tem aí dentro dessa tabela."

🔍 Quebra rápida do comando:
SELECT → É o que você quer buscar.

* → Quer dizer "todos os campos".

FROM Pessoas → De qual tabela? Da tabela Pessoas.

🧠 Dica de gente esperta:
Quando seu banco tiver muitas colunas ou quando quiser performance ou organização, é melhor especificar só os campos que você quer, tipo:

SELECT PES_NOME, PES_EMAIL FROM Pessoas;
_______________________________________________________________________________________________________________________________________________________________________

🤔 DESAFIO 6: E se você quiser ver apenas a pessoa com CPF = '44003132053'?
Como seria esse comando?
#MEU COMANDO PARA VER APENAS A PESSOA COM O CPF = '44003132053'
SELECT* FROM Pessoas
WHERE PES_CPF = '44003132053'

🧠 O que você acabou de fazer aqui:
Você fez uma consulta com filtro — pediu para o banco mostrar somente os registros que atendem a uma condição.

📌 Esse tipo de filtro (WHERE) é a base para:
Buscar por um CPF específico (como você fez)

Buscar por ID (ex: WHERE PES_ID = 1)

Buscar por nome, idade, e-mails... tudo!
_______________________________________________________________________________________________________________________________________________________________________

🎯 Agora que você dominou a base do SQL, vamos organizar o próximo passo do nosso projeto fullstack:
Aqui está um mini roadmap (que a gente já começou!):

✅ Criar o banco e a tabela no SQL Server

✅ Inserir e consultar dados com SQL

✅ Pensar no modelo de dados no C# (classe Pessoa)

🔜 Criar a API ASP.NET Core (endpoint GET, POST, etc)

🔜 Fazer o Angular consumir essa API
_______________________________________________________________________________________________________________________________________________________________________

🧪 DESAFIO 7:
Se você fosse criar uma classe em C# chamada Pessoa que representasse essa tabela, como ela seria?
Lembra: você tem os campos:

ID

Nome

Idade

CPF

Email

Pensa como se fosse uma classe C# mesmo, com public, get, set etc.
Manda ver! Não precisa estar perfeita, só tenta.

------------------------------------------------------------------------------------------------------------------------------------
EU DISSE: os nomes das propriedades da model do backend  devem ser idênticos aos campos do banco?


O ChatGPT disse:
🔍 Ótima pergunta, e ela mostra que você está começando a pensar como um desenvolvedor de verdade!

A resposta é:

❌ Não precisam ser idênticos,
✅ mas é importante que você saiba o que está mapeando.

💡 Explicação como se fosse pra criança:
Pensa assim:

No banco, você chama a coluna de PES_NOME (porque tem um padrão de nome, né?).

No código C#, você pode chamar isso de Nome.

⚠️ Só que... o C# vai precisar saber que "Nome" no código = "PES_NOME" no banco.
Se você usar ADO.NET puro, você é quem faz esse mapeamento "na mão" — ou seja, você vai escrever algo como:

csharp
Copiar
Editar
pessoa.Nome = reader["PES_NOME"].ToString();
✅ Dica prática:
No banco, siga o padrão da empresa (como PES_ID, PES_NOME, etc.).

No código C#, use nomes mais simples e legíveis (como Id, Nome, Cpf), porque:

Fica mais limpo

Mais fácil de trabalhar no frontend depois

Mais intuitivo

🎓 Como seria a classe Pessoa em C#:
csharp
Copiar
Editar
public class Pessoa
{
    public int Id { get; set; }
    public string Nome { get; set; }
    public int Idade { get; set; }
    public string Cpf { get; set; }
    public string Email { get; set; }
}
E quando você buscar os dados do banco com ADO.NET, você só precisa mapear manualmente os campos:

csharp
Copiar
Editar
var pessoa = new Pessoa
{
    Id = Convert.ToInt32(reader["PES_ID"]),
    Nome = reader["PES_NOME"].ToString(),
    Idade = Convert.ToInt32(reader["PES_IDADE"]),
    Cpf = reader["PES_CPF"].ToString(),
    Email = reader["PES_EMAIL"].ToString()
};
🚀 Conclusão:
Você é quem faz o “meio de campo” entre o nome técnico do banco e o nome amigável da aplicação.

Isso te dá liberdade de deixar o código mais bonito sem mexer na estrutura do banco.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

CRIEI :
 public class Pessoa
 {
     
     public int PES_ID { get; set; }
     public string PES_NOME { get; set; }
     public int PES_IDADE { get; set; }
     public string PES_CPF { get; set; }

     public string PES_EMAIL { get; set; }
 }


O ChatGPT disse:
🔧 Boa, você criou certinho! E isso mostra que você está mantendo os nomes iguais aos do banco, o que pode ajudar bastante no começo, especialmente se você ainda estiver se familiarizando com o mapeamento manual.

Mas agora vou te fazer pensar, porque é assim que você vai aprender a se virar sozinho depois:

🤔 Reflexão:
Se você mantiver os nomes da model em C# iguais aos do banco, o que isso facilita?
E o que pode dificultar mais pra frente?

🧠 Dica pra você pensar:
Quando for mostrar isso no Angular, o nome PES_NOME vai aparecer direto na resposta JSON da API.

Acha bonito mostrar isso na tela?

Seu colega de frontend vai entender que PES_EMAIL é o e-mail da pessoa?

Se mais pra frente o padrão do banco mudar (ex: mudar de PES_ pra P_), o que acontece com o seu código?

Se você quiser renomear o campo no C#, você pode fazer isso livremente, desde que saiba como ligar o nome do banco com o nome do código.

💡 Resumo: dois caminhos possíveis

Caminho	Model igual ao banco	Model com nomes mais limpos
✅ Vantagem	Fácil de copiar/colar do banco	Código mais limpo e amigável
⚠️ Desvantagem	JSON feio, código menos legível	Requer mapear os nomes manualmente
📘 Exemplo de model “limpa”:
csharp
Copiar
Editar
public class Pessoa
{
    public int Id { get; set; }
    public string Nome { get; set; }
    public int Idade { get; set; }
    public string Cpf { get; set; }
    public string Email { get; set; }
}
Aí, no seu repositório com ADO.NET, você faz o "trabalho sujo" só uma vez:

csharp
Copiar
Editar
pessoa.Nome = reader["PES_NOME"].ToString();
Quer continuar com os nomes iguais ao do banco por enquanto? Sem problema! É até bom pra você enxergar melhor a ligação.
Mas só queria te fazer pensar como um programador mesmo. 😉

